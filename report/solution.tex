\section{Solution}
\subsection{Creating the staging memories}
\label{sub:creating_the_staging_memories}
The staging memories that make up the pipeline are simple to implement. By viewing the schematics of the processor in Figure~\ref{img:staging_memories} one can easily identify which signals needs to be saved between each of the five stages. These staging memories contains two ports (in and out) for every variable they store. In addition to the ports they have a register for each signal, and they also take in the clock signal in order to know when to read/write.\\

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{./img/staging_memories}
	\caption{The staging memories highlighted in green}
	\label{img:staging_memories}
\end{figure}

The four staging memories are discussed below.
\begin{description}
	\item [IF/ID] \emph{Instruction fetch - Instruction decode}\\
The only values traveling between these two stages are the PC, which is used for calculating the branch, and the current instruction read from instruction memory.
	\item [ID/EX] \emph{Instruction decode - Execute} \\
The \emph{Instruction decode}-stage contains the control unit, hence this staging memory must save all the control signals. While this unit only reads the \emph{opcode} (first six bits of the instruction), the \emph{Instruction decode}-stage also contains units that read the other parts of the instruction, as displayed in Figure~\ref{img:staging_memories}.~\emph{td} and \emph{tr} (see Appendix \ref{MIPS_SHEET} for the instruction formats) are read by the register file but also passed onwards to be used in calculating RegDst later on, and the sign extended version of the lower 16 bits are calculated for indirect addressing.
	\item [EX/MEM] \emph{Execute - Memory operation}\\
When the execution reaches this staging memory, the control signals for the \emph{Execute}-stage (ALUOp, RegDst, ALUSrc) have done their part, and is no longer saved.
	\item[MDM/WB] \emph{Memory operation - Write back}\\
This staging memory is the last one, and only contains control signals for one stage, the \emph{Write Back}-stage. In the previous stage all the \emph{Memory operation} control signals (Branch, MemWrite, MemRead) were used. The PC has also gotten its correct value (the branch operation has taken place) and this signal does not need to be saved any more.
\end{description}

\subsection{Connecting the staging memories to the processor} % (fold)
\label{sub:connecting_the_staging_memories_to_the_processor}
The various parts of the pipeline were connected by forwarding the output signals of the pipeline registers to the receiving components of the processor. The output of these components is then sent into the next pipeline element. If the signal is not needed in a particular stage of the pipeline but needed at a later stage, the signal is simply forwarded to the next pipeline register.
% subsection connecting_the_staging_memories_to_the_processor (end)

\subsection{Shifting the pipeline} % (fold)
\label{sub:shifting_the_pipeline}
The switch to the next stage of the pipeline happens on the rising edge of the processor clock. This causes all of the staging memories to switch its output signal to the signal it is currently receiving. Since this happens on all the pipeline registers simultaneously, the effect is that every signal in the processor is transferred from one stage in the pipeline to the next.
% subsection shifting_the_pipeline (end)


\subsection{Jump instruction}
\label{sub:jump_instruction}
Whenever a jump instruction is encountered, any new data flow has to be halted for one cycle. If not, a new instructions will already have entered the pipeline by the time the jump control signal and the new instruction address returns from the decode step. The programmer has to take this into account and resolve the issue by writing \emph{noop} into the program immediately after a jump.

\subsection{Reading from data and instruction memory}
\label{sub:reading_from_data_and_instruction_memory}
When reading a value from either of these two memories, it takes one clock cycle from when the control signal has been asserted, to the value is available on the result bus. To accommodate for this latency, any signals read from the two memories are not stored in the staging memories, but are directly connected to the signals in the following stage. This way the system is not delayed as a result of the slow memories. Figure~\ref{bypassing_data_memory} shows how the result from the data memory bypasses the \emph{MEM/WB} staging memory. The same principle counts for when data read from the instruction memory bypasses the \emph{IF/ID} staging memory.

\begin{figure}[H]
	\includegraphics[scale=0.4]{./img/bypassing_data_memory}
	\caption{Bypassing the data memory}
	\label{bypassing_data_memory}
\end{figure}

\subsection{A note on the naming convention used}
\label{sub:a_note_on_the_naming_convention_used}
There are many signals in the design that carry the same data between the various stages. To avoid confusion, a strict naming convention was used:

\begin{description}
	\item[Staging memories] The staging memories are named after which two stages they connect. See section \ref{sub:creating_the_staging_memories} for more details.
	\item[Ports used for control signals on the different staging memories] Each control signal is prefixed with the stage at which it is needed, and postfixed with whether it is an in or out port. By comparing figure \ref{code:staging_memory} and \ref{code:staging_memory_ex}, we see that the control signals that are used in the EX stage is no longer included in the EX/MEM staging memory. 
	\item[Internal signals] The internal signals are prefixed with the stage in which they are contained \emph{as long as the data on it is not final}. In other words, each signal without a stage-name prefix is final, and will not be changed by any later stages. See figure \ref{naming_convention_expamle} as an example.
\end{description}

\begin{figure}[H]
\begin{lstlisting}[language=VHDL]
entity id_ex_stage_mem is
port(
	--...
    wb_RegWrite_in 	: in std_logic;
    wb_RegWrite_out : out std_logic;
    
    wb_MemToReg_in  : in std_logic;
    wb_MemToReg_out : out std_logic;
    
    m_Branch_in		: in std_logic;
    m_Branch_out	: out std_logic;
    
    m_MemWrite_in	: in std_logic;
    m_MemWrite_out  : out std_logic;

    ex_RegDst_in	: in std_logic;
    ex_RegDst_out	: out std_logic;
    
    ex_AluOp_in		: in std_logic_vector(1 downto 0);
    ex_AluOp_out	: out std_logic_vector(1 downto 0);
    
    ex_AluSrc_in	: in std_logic;
    ex_AluSrc_out	: out std_logic;
	--...
);
end id_ex_stage_mem;
\end{lstlisting}
\caption{Code snippet from the ID/EX staging memory}
\label{code:staging_memory}
\end{figure}


\begin{figure}[H]
\begin{lstlisting}[language=VHDL]
entity ex_mem_stage_mem is

port(
	-- ...
    wb_RegWrite_in 	: in std_logic;
    wb_RegWrite_out : out std_logic;
    
    wb_MemToReg_in 	: in std_logic;
    wb_MemToReg_out : out std_logic;
    
    m_Branch_in		: in std_logic;
    m_Branch_out	: out std_logic;
    
    m_MemWrite_in	: in std_logic;
    m_MemWrite_out  : out std_logic;
	--... 
);

end ex_mem_stage_mem;
\end{lstlisting}
\caption{Code snippet from the EX/MEM staging memory}
\label{code:staging_memory_ex}
\end{figure}

\begin{figure}[H]
	\includegraphics[scale=0.4]{./img/naming_convention_example}
	\caption{An example of how the naming convention works.}
	\label{naming_convention_expamle}
\end{figure}



\input{pipeline}
\input{assembler}